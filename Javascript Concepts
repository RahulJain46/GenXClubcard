Localstorage and cookies :
Web storage is nothing but client side storage.Right now we are using cookies for the purpose of storing objects locally in client machine(in browser).
Cookies can able to store only 4k of data. For each domain browser will assign 4k of memory.
Each time browser has to send cookie along with HTTP request,it’s inefficient especially if you are using mobile device with not a lot of bandwidth.

A simple JavaScript API in the browser for storing Key value pairs that are persistent and you are not limited to 4k of memory.
All browsers today offering 5-10 MB of storage in every user’s browser.i.e., For each domain 5MB of local storage.
Example : 
localstorage.setItem("key1","value1"); 
var value=localstorage.getItem("key1");
alert(value);


Session storage : 
If you substitute the global variable sessionStorage everywhere you’ve used localStorage then your items are stored only during the browser session. So, as soon as that session is over (in other words, the user closes the browser window), the items in storage are removed.The sessionStorage object supports exactly the same API as Local Storage.

if you want to store arrays or objects into local storage use JSON.stringify to store the value and JSON.parse to retrive the value.

 == checks for value equality and === checks for both value and type equality. 
 
 
Tokenizing/Lexing
Breaking up a string of characters into meaningful (to the lan‐ guage) chunks, called tokens. 

Parsing
taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This tree is called an “AST” (abstract syntax tree).
Engine
Responsible for start-to-finish compilation and execution of our JavaScript program.
Compiler
One of Engine’s friends; handles all the dirty work of parsing and code-generation
Scope
Another friend of Engine; collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.
undeclared : look up occurance of first time and havn't notice , will throw this error.
ReferenceError : find a variable, anywhere in the nested scopes, this results in a ReferenceError being thrown by the engine.
Strict Mode, :  if the program is not running in “Strict Mode,”1 then the global scope will create a new vari‐ able of that name in the global scope, and hand it back to Engine.
One such behavior is that it disallows the automatic/implicit global variable creation

Both eval(..) and with cheat the otherwise author-time defined lex‐ ical scope by modifying or creating new lexical scope at runtime.
 in the pessimistic sense, most of those optimizations it would make are pointless if eval(..) or with are present, so it simply doesn’t perform the optimizations at all.
