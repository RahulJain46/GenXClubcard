Injection:
 Now this attacker is going to issue a malicious request. It's important to understand that this is normally just an HTTP request and the malicious payload might be part of the query string or might be part of a form variable posted to the website. All the attacker has done is manipulate part of an otherwise legitimate request. Now the website takes that request and it converts it into a query. What the attacker is trying to do in a SQL Injection attack is modify that query such that it performs an action in the database that it was not originally intended to do. So, for example, accesses data that the page they hit was not actually designed to do. Now the database gets that query and it responds with an output.
 Prevent :
 
  that you'll see mentioned multiple times throughout this course, and that is to Whitelist untrusted data. So we just looked at what untrusted data is. That's what comes from external users and we have no control over what they pass us. 
  The other really big one for Injection is parameterization of statements. So particularly when we're talking about SQL Injection, what we're really talking about is saying, hey, how can we keep our query, and again, on the previous slide that was a SELECT * FROM Widget, how can we keep that guy separate from the untrusted data, because the risk really happens when the untrusted data breaks out of that parameter context and enters the query context, so it no longer becomes a piece of data, it actually becomes part of the SQL statement. So we have this paradigm within databases called parameterization
  The other big thing that can be done is really fine-tuning the database permissions. So, for example, the page which allows someone to log in, does it actually need to be able to read, say, financial data for the user or can we make sure that when someone hits the login page and that web application connects to the database, that it uses a SQL account that only has access to the tables and the columns it needs. That is the "principle of least privilege", give each component of the system only the access rights to the other parts that it absolutely positively needs. Excessive rights very frequently kill our security and open up some serious risks such as SQL Injection.
  
  Broken Authentication and Session Management:
  
 So the first one here is Auth cookie theft. Now an Auth cookie is a little piece of information that the website gives the user when they first login. Every time the user comes back to the website and makes another request, they send that cookie with them for identification. attackers want that cookie. If they get the cookie, they can hijack the session. So how could they get it? Well, one way is they could exploit an XSS risk, Cross-Site Scripting risk,
  The other thing they could do is they could Sniff it over an insecure connection. Now what I mean by that is that if that Auth cookie is going across an HTTP connection, not an HTTPS connection, using SSL, using a certificate mechanism, and an attacker can observe that traffic,
  The other option is Session ID theft. Now inevitably, what an Auth cookie has is some form of Session ID, but it doesn't have to be persisted by cookie. Often, you'll see systems that persist the Session ID in the URL. You might see this sometimes when you log into a website and you get a very large random string in your URL. When systems are badly designed, that string is enough to log someone else in to the users account. Now this is a real risk because it means things like if the users, say, copied and pasted the URL and tweeted it, could anybody click on that and be authenticated as the user. By the same token, what if that URL is sent out via email, either by the website wanting to give the user a real shortcut to an authenticated link or, again, by the user just wanting to be social and share the URL. 
  
  prevent : 
   One of them is cookies can use what we refer to as the HttpOnly flag. :  make it secure
    That sounds basic, but the trade-off is that if you expire user session too quickly they then have to login again. Nobody likes having to login again, it's not particularly pleasant, but it is very secure. So there is this trade-off that is a very, very case-by-case decision about how can we find the right balance between expiring the session quickly to reduce that window of risk, and not expiring it so quickly that it impacts the usability and possibly impacts our attention of a customer.
    Reset password :  put old password and then allow 
    Password should be strong .
    
